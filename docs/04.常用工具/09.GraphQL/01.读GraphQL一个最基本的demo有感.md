---
title: 读GraphQL一个最基本的demo有感
date: 2022-01-07 22:58:03
permalink: /pages/83084a/
categories:
  - 工具
  - GraphQL
tags:
  - 
---


### 由来
在学习 GraphQL 时候，下载了第一个Demo，里面有这么一个文件,是开发 GraphQL 的代码开发规范，让人记忆深刻。这些优秀的习惯一个个汇聚，坚持下去，才能成就一个长时间可维护、结构清晰的软件！


<!-- 注意带英文感叹号的内容是图片，不带感叹号的是链接！-->
![123][发现宝藏]

### 通用准则

1. 我们更喜欢0依赖。不要把 Guava,apache-commons,spring-xxx,甚至n多个版本的StringUtils方法的Jar引入。更少的依赖意味着 graphql对大多数人更有作用。
2. 我们不想使用Http协议。我们是运行graphql查询的底层引擎，其他层可以更好地处理其他问题，例如 JSON 和 HTTP。
3. 我们更喜欢简单的代码而不是聪明的代码。使用命名良好的方法应该是可读的。 巧妙的嵌套流和 lambdas (函数式编程) 不是我们的东西。
4. 我们更喜欢一般而不是具体。 所以代码应该普遍适用于用例，而不是高度特定于某些用例，即使它需要更多的设置。也就是必须要有抽象性，是解决某一类的问题的代码，而不是某一个问题的代码。

### 更多特殊的话题

1. 使用@Public 和@Internal 来传达支持的稳定性级别。
2. 永远不要将类或方法设为包级别私有或protected：将其设为 public 或 private，并使用 @Internal 传达该类可以在不通知的情况下更改。 用户可以自行决定使用内部事物时的风险

### 可选值和空值

1. 我们混合了 Optional 和允许空值，因为 GraphQL Java 最初是用 Java 6 编写的。
2. 我们的目标是不使用 Optional，以保持整体一致。

### 单元测试和依赖

1. 所有的测试都是用Spock编写。Spock地址：http://spockframework.org/
2. 所有的新代码都必须有单元测试。
3. 一般情况是每个类的每个方法默认都是非静态的，每个依赖项都是一个具有包私有可见性的实例字段，以便在单元测试中轻松模拟，属性字段应使用@VisibleForTesting 进行注解。

例如：

```java
public class Foo {

  @VisibleForTesting
  Bar bar = new Bar();


  public void doSomething(){
    ...
  }

} 

```

### 静态方法
1. 静态方法只允许用于功能非常有限且没有任何依赖关系的方法。 静态方法意味着您永远不想mock它们。
典型的例子是像 GraphQLTypeUtil.isNonNull() 这样的 util 方法

### 是否用工具类
1. 不要混合静态和非静态方法（工厂方法除外）：每个类要么是只有静态方法的通用“Util”类，要么是没有静态方法的类。

### 命名
1. 命名是可读源代码的关键要素。 每个变量和方法都应该有一个明确的名称。 除了索引迭代外，单个字符变量名永远都行不通。

### 注释
1. 公共 API 应通过 JavaDoc 进行记录。 JavaDoc 应该描述应该如何以及为什么应该使用这个类/方法。 它不应指定实现的细节。
2. 内部 API 没有 JavaDoc，通常我们会尽可能避免任何形式的注释。


### 方法大于注释
1. 方法中的大多数注释都可以通过创建方法并为方法名称提供注释文本来重构。


### 不变性和构建器
1. 每个公共数据类都应该是：
 - 不可变
 - 有一个 Builder 类
 - 有一个转换方法

每个承载数据的类应该是不变的，并且应该包含用工厂方法生成的(例如 newFoo())一个 公共的、静态的内部类 Builder。
 <!-- TODO -->

### 默认的集合类型
1. 使用 Set、List、Map的默认方式是：
```java
   List<Foo> fooList = new ArrayList<>()
   Set<Foo> fooSet = new LinkedHashSet<>()
   Map<Foo> fooMap = new LinkedHashMap<>()
```
通过使用通用接口而不是使用实现，我们确保我们不依赖任何特定于 impl 的东西。
Set 和 Map 的默认实现应该是 LinkedHashSet 和 LinkedHashMap，因为它提供了稳定的迭代顺序。

::: warning
LinkedHashSet 和 HashSet 有什么区别？
:::

::: warning
LinkedHashMap 和 HashMap 有什么区别？
:::

### Stream 循环、for 循环和 角标循环
1. 通常，用 Stream 是没问题的，但是必须保持简单。应避免映射内部的流映射，并将内部逻辑重构为方法。（非常赞同）
2. 也可以使用传统的 for 循环或其他结构：有时候它比Stream API更具有可读性。Stream API 不是其他循环或迭代的替代品。

### 最大缩进为两位
1. 最重要的规则之一是尽可能减少缩进的数量。 一般来说，最大数量应该是两个。 这意味着条件内的 for 循环是可以的。 for 循环内的 for 循环内的条件不是。
2. 提取成方法是最简单的处理方式。

### 方法应及时返回
1. 及早方法返回可以避免缩进
```java
public void foo() {
  if(cond) {
    return;
  }
  ...do something
}
```
上述代码比下面的要好：
```java
public void foo() {
  if(!cond) {
    ...do something
  }
}
```

### 最大行长和多行语句
1. 我们没有严格的最大行长。 但当然，每个语句都应该受到限制。 与其说是长度，不如说是语句的作用。
2. 如果一个语句有多行，它应该被分解成相同的缩进级别。

下面这个例子是可以的：
```java
   return myMap
                .entrySet()
                .stream()
                .map(entry -> mapEntry(entry))
                .collect(Collectors.toList());
```

再下面这个例子是有问题的：
```java
    return fooListOfList.stream().map(
                 fooList -> fooList.stream()
                        .sorted((x,y) -> sort(x,y))
                        .map(foo -> foo.getMyProp())
                        .collect(toList())
```
它在流中嵌套了一个流，并且内部流又有一个 lambda表达式。 内部流应该被提取到一个额外的方法中，并且每个方法调用都应该在一个新行上：
```java
 return fooListOfList
                 .stream()
                 .map(this::mapFooList)
                 .collect(toList());
```

### 每个类都有自己的文件：避免内部类和内部接口
1. 一般来说，每个类/接口都应该有自己的文件。内部类几乎在任何情况都不该使用（尤其是 public 的类）。 每个类都应该有自己的文件，以便更容易阅读和探索代码。

### 使用 graphql.Assert 而不是 Objects 
我们维护自己的一小组 Assert 实用程序方法。 为了保持一致而不要使用 Objects.requireNonNull 等方法。

### 对公共 API 中的方法参数处理
不要对接口方法使用特定的参数，而是使用 FooEnvironment 参数。 这确保了在添加新输入时未来的向后兼容性。





[发现宝藏]: /img/02.GraphQL/1641570775.jpg

<!-- 引入图片和链接有两种方式
1、![xx](xx) 和 [xx](xx)
2、 ![][id1] 和[][id2] 
后面再来个 [id1]: https://www.baidu.com (标题)  或  [id1]: https://www.baidu.com "标题"

链接也可直接用 <https://www.baidu.com>
-->